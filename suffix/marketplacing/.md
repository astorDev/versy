# Marketplacing a Shell GitHub Action

<img src="./ferret-in-bazaar.jpeg" width="400"/>

This all started with me wanting a CI versioning system. I needed a GitHub action. In the GitHub marketplace. I also wanted the action's logic to be reusable elsewhere. With that in mind, I've opened my machine and start coding.

> Based on a true story.

## Overcoming GitHub Marketplace Limitations

I have a strict routine: git flow, constant and thorough testing, small.  Before the story we need to understand how GitHub Marketplace makes live harder. There is [quite a few](https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace#about-publishing-actions) limitations for a marketplace actions. Here are the ones that bit me:

1. Repository must **not** contain any workflow files.
2. Repository must contain a single action.
3. The action's metadata file (`action.yml` or `action.yaml`) must be in the root directory of the repository.

My envisioned repository started to fall apart. My ambition was to create a comprensive project with a few cohesive actions and scripts. The rules not only block that but also make it impossible to **fully** test the action. A rich repository was stuck as a goal in my head. A poor project was manifesting itself from the limitations. I was looking for a work-around. So, I've decided to have two:

- The "Motherland" Repository. The actual logic, workflows and tests, and basically everything important lays here.
- The "Marketplace" Repository. The tiniest wrapper around the action from the motherland repository with no purpose other than satisfying marketplace terms.

## Scripts from the Motherland

For the story I'll focus on the small part of a [bigger picture](https://github.com/astorDev/versy), called `suffix`. The goal was to have a version suffix generator, based on the current branch.
So, I forked a branch called `marketplacing-suffix` and started coding. I put logic in `suffix/marketplacing/.sh`, for the sake of reusability:

```sh
if [ "$BRANCH" = "main" ]; then
    echo ""
else
    echo "$BRANCH" | sed 's/\//-/g'
fi
```

And verified it straight away with a local script `suffix/marketplacing/test.sh`:

```sh
export BRANCH=feature/one && echo "BRANCH=$BRANCH => SUFFIX='$(sh .sh)'"
export BRANCH=main && echo "BRANCH=$BRANCH => SUFFIX='$(sh .sh)'"
```

A Github public repository file content is accessible by `https://raw.githubusercontent.com/{username}/{repository-name}/{branch}/{path-to-file}`. So a repository script can be called using `curl`. Based on that I've created the first version of a test workflow `.github/workflows/suffix-marketplacing.yaml`:

```yaml
on:
  push:
    paths:
      - '.github/workflows/suffix-marketplacing.yaml'
      - 'suffix/marketplacing/**'

jobs:
  remote-call:
    runs-on: ubuntu-latest
    steps:
      - run: curl -sSL https://raw.githubusercontent.com/astorDev/versy/$BRANCH/suffix/marketplacing/.sh | sh
        env:
          BRANCH: ${{ github.ref_name }}
```

I pushed all the changes to the current branch (`marketplacing-suffix`). The workflow successfully `echo`ed `marketplacing-suffix`.

## Motherland action

Next step was to actually create a reusable github action. The `remote-call` simply `echo`es the suffix, while the action has to output it for future usages by other scripts. So I've udpated to script to

1. Write the call output in a variable:

```sh
SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${BRANCH}/suffix/marketplacing/.sh | sh)
```

2. Put it to the GitHub output:

```sh
echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
```

There was one more unobvious problem with the script, however. In the workflow I've constructed the script path using `${{ github.ref_name }}`. It worked good for me, but for a other action user `${{ github.ref_name }}` will be `whatever-feature/i-am-working-on` which just wouldn't exists in my repository. So the suffix branch and script branch should be separated, allowing a remote user to pick script branch, like that:

```yaml
run: | 
    SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${SCRIPT_BRANCH}/suffix/marketplacing/.sh | sh)
    echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
env:
    SCRIPT_BRANCH: ${{ inputs.script-branch }}
    BRANCH: ${{ github.ref_name }}
```

After addition of required metadata the action looked like this:

```yaml
name: 'Suffix'
description: 'Generate Suffix based on the current branch'

inputs:
  script-branch:
    description: 'Name of the branch in suffix repository'
    required: false
    default: 'main'
outputs:
  suffix:
    description: 'The generated suffix'
    value: ${{ steps.suffix.outputs.suffix }}
runs:
  using: "composite"
  steps:
    - id: suffix
      shell: bash
      run: | 
        SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${SCRIPT_BRANCH}/suffix/marketplacing/.sh | sh)
        echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
      env:
        SCRIPT_BRANCH: ${{ inputs.script-branch }}
        BRANCH: ${{ github.ref_name }}
```

An action can be called from a workflow by `{username}/{repositoryname}/{action-folder-path}@{branch-name}`. This is hardly compatible with git flow, since the `branch-name` couldn't be provided dynamically. So I grudgingly hard-coded the current branch:

```yaml
uses: astorDev/versy/suffix/marketplacing@marketplacing-suffix
```

At least, I could use current `script-branch`. Adding a step to `echo` the suffix output, I got:

```yaml
local-action:
  runs-on: ubuntu-latest
  steps:
    - id: suffix 
      uses: astorDev/versy/suffix/marketplacing@marketplacing-suffix
      with:
        script-branch: ${{ github.ref_name }}
    - run: echo "Suffix is '${{ steps.suffix.outputs.suffix }}'"
```

## The Marketplace Repository

The action ran successfully with the next push. It was time to start marketplacing the action. At least, I could have marketplace repository reference action from the main branch. So I've merged current changes to the main branch. I didn't delete `marketplacing-suffix` branch, however, so that the workflow will still work.