# Marketplacing a Shell GitHub Action

<img src="./ferret-in-bazaar.jpeg" height="300"/>

> Based on a true story.

This all started with me wanting a CI versioning system. I wanted the logic to be reusable, so I chose `.sh` file as my base packaging. Wrapped with a GitHub Action. I also wanted the action to end up in the GitHub marketplace. There could be a whole saga about the [project](https://github.com/astorDev/versy). But this article is just a story about me working on a particular action, called `suffix`. The goal of the action is to generate version suffix based on the current git branch.

## Overcoming GitHub Marketplace Limitations

Before the story, here's some background on the architectural decisions. I have a strict routine: git flow, constant and thorough testing, small steps. Having that it was very important to first read [GitHub marketplace limitations](https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace#about-publishing-actions), in particular:

1. Repository must **not** contain any workflow files.
2. Repository must contain a single action.
3. The action's metadata file (`action.yml` or `action.yaml`) must be in the root directory of the repository.

When I've read that, I felt that my vision for the project started to fall apart. My ambition was to create a rich actions and scripts repository. The marketplace rules significantly limit that. Besides that, they also make it impossible to **fully** test the actions. 

I was staring at two pictures. My imaginery picture of a rich repository and a poor repository rendering itself from the limitations. I couldn't find a way to mix them. So... I've decided to have both:

- The "Motherland" Repository. A container for the actual logic, workflows, tests, and basically everything important.
- The "Marketplace" Repository. The tiniest wrapper around the action from the motherland repository with no purpose other than satisfying marketplace terms.

## Scripts from the Motherland

The story begins with me creating a branch called `marketplacing-suffix`. I defined the actual logic in `suffix/marketplacing/.sh`:

```sh
if [ "$BRANCH" = "main" ]; then
    echo ""
else
    echo "$BRANCH" | sed 's/\//-/g'
fi
```

And verified it straight away with a local script `suffix/marketplacing/test.sh`:

```sh
export BRANCH=feature/one && echo "BRANCH=$BRANCH => SUFFIX='$(sh .sh)'"
export BRANCH=main && echo "BRANCH=$BRANCH => SUFFIX='$(sh .sh)'"
```

A Github public repository file content is accessible by `https://raw.githubusercontent.com/{username}/{repository-name}/{branch}/{path-to-file}`. So a repository script can be called using `curl`. Based on that I've created the first version of a test workflow `.github/workflows/suffix-marketplacing.yaml`:

```yaml
on:
  push:
    paths:
      - '.github/workflows/suffix-marketplacing.yaml'
      - 'suffix/marketplacing/**'

jobs:
  remote-call:
    runs-on: ubuntu-latest
    steps:
      - run: curl -sSL https://raw.githubusercontent.com/astorDev/versy/$BRANCH/suffix/marketplacing/.sh | sh
        env:
          BRANCH: ${{ github.ref_name }}
```

I pushed all the changes to the current branch (`marketplacing-suffix`). The workflow successfully `echo`ed `marketplacing-suffix`.

## Motherland action

Next step was to actually create a reusable github action. The `remote-call` simply `echo`es the suffix, while the action has to output it for future usage by other scripts. So I've updated the script to

1. Write the call output in a variable:

```sh
SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${BRANCH}/suffix/marketplacing/.sh | sh)
```

2. Put it to the GitHub output:

```sh
echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
```

There was one more unobvious problem with the script, however. In the workflow, I've constructed the script path using `${{ github.ref_name }}`. It worked well for me, but for a another action user `${{ github.ref_name }}` will be `whatever-feature/i-am-working-on` which just wouldn't exist in my repository. So the suffix branch and script branch should be separated, allowing a remote user to pick the script branch, like this:

```yaml
run: | 
    SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${SCRIPT_BRANCH}/suffix/marketplacing/.sh | sh)
    echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
env:
    SCRIPT_BRANCH: ${{ inputs.script-branch }}
    BRANCH: ${{ github.ref_name }}
```

After the addition of the required metadata, the action looked like this:

```yaml
name: 'Suffix'
description: 'Generate Suffix based on the current branch'

inputs:
  script-branch:
    description: 'Name of the branch in suffix repository'
    required: false
    default: 'main'
outputs:
  suffix:
    description: 'The generated suffix'
    value: ${{ steps.suffix.outputs.suffix }}
runs:
  using: "composite"
  steps:
    - id: suffix
      shell: bash
      run: | 
        SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${SCRIPT_BRANCH}/suffix/marketplacing/.sh | sh)
        echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
      env:
        SCRIPT_BRANCH: ${{ inputs.script-branch }}
        BRANCH: ${{ github.ref_name }}
```

An action can be called from a workflow by `{username}/{repositoryname}/{action-folder-path}@{branch-name}`. This is hardly compatible with git-flow, since the `branch-name` couldn't be provided dynamically. So I grudgingly hard-coded the current branch:

```yaml
uses: astorDev/versy/suffix/marketplacing@marketplacing-suffix
```

At least, I could use current `script-branch`. Adding a step to `echo` the suffix output, I got:

```yaml
local-action:
  runs-on: ubuntu-latest
  steps:
    - id: suffix 
      uses: astorDev/versy/suffix/marketplacing@marketplacing-suffix
      with:
        script-branch: ${{ github.ref_name }}
    - run: echo "Suffix is '${{ steps.suffix.outputs.suffix }}'"
```

## The Marketplace Repository

Before moving the marketplace repository I needed to get back to the git flow. I've merged the changes as is in the `main`. However, I didn't remove the `marketplacing-suffix` branch, so that `local-action` would still work. Next, I started a new branch called `marketplaced-action`. The first step was to verify the action can now be called from the `main` branch, so I updated `local-action` to:

```yaml
local-action:
  runs-on: ubuntu-latest
  steps:
    - id: suffix
      uses: astorDev/versy/suffix/marketplacing@main
      with:
        script-branch: ${{ github.ref_name }}
    - run: echo "Suffix is '${{ steps.suffix.outputs.suffix }}'"
```

This worked. I was comfortable starting the marketplace repository. I created it from GitHub with the default README file. Created a branch `init` and started coding. Actually, the only thing I did was a trivial wrapper over the motherland action `action.yml`:

```yaml
name: 'Versy Suffix'
description: 'Generate Suffix based on the current branch'

inputs:
  script-branch:
    description: 'Name of the branch in suffix repository'
    required: false
    default: 'main'
outputs:
  suffix:
    description: 'The generated suffix'
    value: ${{ steps.suffix.outputs.suffix }}
runs:
  using: "composite"
  steps:
    - id: suffix
      uses: astorDev/versy/suffix/marketplacing@main
      with:
        script-branch: ${{ inputs.script-branch }}
```

Then it was time for testing. But, as you may remember, the marketplace repository could not contain a workflow. I pushed the action to the `init` branch. And added the required check to the motherland repository.

```yaml
marketplace-action:
    runs-on: ubuntu-latest
    steps:
      - id: suffix
        uses: astorDev/suffix/@init
      - run: echo "Suffix is '${{ steps.suffix.outputs.suffix }}'"
```

When this worked I was ready to merge `init` to the `main` branch in the `suffix` repository. And as a final step, I've updated `marketplace-action` to `use` `astorDev/suffix@main`, verified it, and merged the `marketplaced-action` branch to the `main` in `versy` (motherland) repository.

## Publishing to the marketplace

After merging `init` to `main`. A banner suggesting publishing to the marketplace appeared.

<img src="./marketplace-publish-banner.png" width="700" />

I've followed the link, actually hoping to get away with requiring access to the action via the branch name. But the release form required me to pick a tag. So first, I needed to push a tag:

```
git tag v1.0
git push origin v1.0
```

After that, I filled out the publication form:

<img src="./marketplace-publish-form.png" width="700" />

Hit `Publish the release`. And the action automatically appeared in the marketplace.

<img src="Marketplaced.png" width="700" />

Remember, that was the default README by GitHub. After, that I updated the README in the `main` branch and it was automatically updated in the Marketplace. After the update the action's marketplace looked a lot like [how it looks today](https://github.com/marketplace/actions/versy-suffix):

<img src="marketplaced-updated.png" width="700" />

