# Marketplacing a Shell GitHub Action

<img src="./ferret-in-bazaar.jpeg" height="300"/>

> Based on a true story.

This all started with me wanting a CI versioning system. I wanted the logic to be reusable, so I chose `.sh` file as my base packaging. Wrapped with a GitHub Action. I also wanted the action to end up in the GitHub marketplace. There could be a whole saga about the [project](https://github.com/astorDev/versy). But this article is just a story about me working on a particular action, called `suffix`. The goal of the action is to generate version suffix based on the current git branch.

## Overcoming GitHub Marketplace Limitations

Before the story, here's some background on the architectural decisions. I have a strict routine: git flow, constant and thorough testing, small steps. Having that it was very important to first read [GitHub marketplace limitations](https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace#about-publishing-actions), in particular:

1. Repository must **not** contain any workflow files.
2. Repository must contain a single action.
3. The action's metadata file (`action.yml` or `action.yaml`) must be in the root directory of the repository.

When I've read that, I felt that my vision for the project started to fall apart. My ambition was to create a rich actions and scripts repository. The marketplace rules significantly limit that. Besides that, they also make it impossible to **fully** test the actions. 

I was staring at two pictures. My imaginery picture of a rich repository and a poor repository rendering itself from the limitations. I couldn't find a way to mix them. So... I've decided to have both:

- The "Motherland" Repository. A container for the actual logic, workflows, tests, and basically everything important.
- The "Marketplace" Repository. The tiniest wrapper around the action from the motherland repository with no purpose other than satisfying marketplace terms.

## Scripts from the Motherland

The story begins with me creating a branch called `marketplacing-suffix`. I defined the actual logic in `suffix/marketplacing/.sh`:

```sh
if [ "$BRANCH" = "main" ]; then
    echo ""
else
    echo "$BRANCH" | sed 's/\//-/g'
fi
```

And verified it straight away with a local script `suffix/marketplacing/test.sh`:

```sh
export BRANCH=feature/one && echo "BRANCH=$BRANCH => SUFFIX='$(sh .sh)'"
export BRANCH=main && echo "BRANCH=$BRANCH => SUFFIX='$(sh .sh)'"
```

Next step, was to test a remote call to the script. A Github public repository file content is accessible by `https://raw.githubusercontent.com/{username}/{repository-name}/{branch}/{path-to-file}`. So using `curl` I came up with the first version of a test workflow `.github/workflows/suffix-marketplacing.yaml`:

```yaml
on:
  push:
    paths:
      - '.github/workflows/suffix-marketplacing.yaml'
      - 'suffix/marketplacing/**'

jobs:
  remote-call:
    runs-on: ubuntu-latest
    steps:
      - run: curl -sSL https://raw.githubusercontent.com/astorDev/versy/$BRANCH/suffix/marketplacing/.sh | sh
        env:
          BRANCH: ${{ github.ref_name }}
```

After `push`ing to the current branch (`marketplacing-suffix`), the workflow successfully `echo`ed `marketplacing-suffix`.

## Motherland action

Next step was to actually create a reusable github action. I've copied the workflow script to the action. But it needed some modifications. The `remote-call` just logs the suffix, while the GitHub action has to write it's output for the future usage. So I updated the script to:

1. Write the call `echo` in a variable:

```sh
SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${BRANCH}/suffix/marketplacing/.sh | sh)
```

2. Put it to the GitHub output:

```sh
echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
```

There was one more unobvious problem with the script, however. Let's say an external repository used the action. Because of the `BRANCH: ${{ github.ref_name }}` the script path will be constructed with `external-repo-branch-name` like this:

```url
https://raw.githubusercontent.com/astorDev/versy/external-repo-branch-name/suffix/marketplacing/.sh
```

The path just wouldn't exist in the versy repository. Solution I came up with was to separate versioning branch from the suffix script branch:

```yaml
run: | 
  SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${SCRIPT_BRANCH}/suffix/marketplacing/.sh | sh)
  echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
env:
  SCRIPT_BRANCH: ${{ inputs.script-branch }}
  BRANCH: ${{ github.ref_name }}
```

After the addition of the required metadata, the action looked like this:

```yaml
name: 'Suffix'
description: 'Generate Suffix based on the current branch'

inputs:
  script-branch:
    description: 'Name of the branch in suffix repository'
    required: false
    default: 'main'
outputs:
  suffix:
    description: 'The generated suffix'
    value: ${{ steps.suffix.outputs.suffix }}
runs:
  using: "composite"
  steps:
    - id: suffix
      shell: bash
      run: | 
        SUFFIX=$(curl -sSL https://raw.githubusercontent.com/astorDev/versy/${SCRIPT_BRANCH}/suffix/marketplacing/.sh | sh)
        echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT
      env:
        SCRIPT_BRANCH: ${{ inputs.script-branch }}
        BRANCH: ${{ github.ref_name }}
```

Now, it was a time to test the action. An action can be called from a workflow by `{username}/{repository-name}/{action-folder-path}@{branch-name}`. The `branch-name` could not be provided dynamically so I grudgingly hard-coded the current branch somewhat staying in the git-flow:

```yaml
uses: astorDev/versy/suffix/marketplacing@marketplacing-suffix
```

At least, I could set `script-branch` dynamically. With a step to `echo` the suffix output, I got the following workflow job:

```yaml
local-action:
  runs-on: ubuntu-latest
  steps:
    - id: suffix 
      uses: astorDev/versy/suffix/marketplacing@marketplacing-suffix
      with:
        script-branch: ${{ github.ref_name }}
    - run: echo "Suffix is '${{ steps.suffix.outputs.suffix }}'"
```

## The Marketplace Repository

Before moving the marketplace repository I needed to get back to the git flow. I've merged the changes as is in the `main`. However, I didn't remove the `marketplacing-suffix` branch, so that `local-action` would still work. Next, I started a new branch called `marketplaced-action`. The first step was to verify the action can now be called from the `main` branch, so I updated `local-action` to:

```yaml
local-action:
  runs-on: ubuntu-latest
  steps:
    - id: suffix
      uses: astorDev/versy/suffix/marketplacing@main
      with:
        script-branch: ${{ github.ref_name }}
    - run: echo "Suffix is '${{ steps.suffix.outputs.suffix }}'"
```

This worked. I was comfortable starting the marketplace repository. I created it from GitHub with the default README file. Created a branch `init` and started coding. Actually, the only thing I did was a trivial wrapper over the motherland action `action.yml`:

```yaml
name: 'Versy Suffix'
description: 'Generate Suffix based on the current branch'

inputs:
  script-branch:
    description: 'Name of the branch in suffix repository'
    required: false
    default: 'main'
outputs:
  suffix:
    description: 'The generated suffix'
    value: ${{ steps.suffix.outputs.suffix }}
runs:
  using: "composite"
  steps:
    - id: suffix
      uses: astorDev/versy/suffix/marketplacing@main
      with:
        script-branch: ${{ inputs.script-branch }}
```

Then it was time for testing. But, as you may remember, the marketplace repository could not contain a workflow. I pushed the action to the `init` branch. And added the required check to the motherland repository.

```yaml
marketplace-action:
    runs-on: ubuntu-latest
    steps:
      - id: suffix
        uses: astorDev/suffix/@init
      - run: echo "Suffix is '${{ steps.suffix.outputs.suffix }}'"
```

When this worked I was ready to merge `init` to the `main` branch in the `suffix` repository. And as a final step, I've updated `marketplace-action` to `use` `astorDev/suffix@main`, verified it, and merged the `marketplaced-action` branch to the `main` in `versy` (motherland) repository.

## Publishing to the marketplace

After merging `init` to `main`. A banner suggesting publishing to the marketplace appeared.

<img src="./marketplace-publish-banner.png" width="700" />

I've followed the link, actually hoping to get away with requiring access to the action via the branch name. But the release form required me to pick a tag. So first, I needed to push a tag:

```
git tag v1.0
git push origin v1.0
```

After that, I filled out the publication form:

<img src="./marketplace-publish-form.png" width="700" />

Hit `Publish the release`. And the action automatically appeared in the marketplace.

<img src="Marketplaced.png" width="700" />

Remember, that was the default README by GitHub. After, that I updated the README in the `main` branch and it was automatically updated in the Marketplace. After the update the action's marketplace looked a lot like [how it looks today](https://github.com/marketplace/actions/versy-suffix):

<img src="marketplaced-updated.png" width="700" />

